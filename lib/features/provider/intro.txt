1. ðŸ“¦ What is Riverpod?

Riverpod is a state management solution for Flutter.
Itâ€™s the successor to provider but:

Compile-time safety

1. No need for BuildContext to access providers

2. Works in Dart (not only Flutter)

3. Better testability


Wrap your app with ProviderScope:

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

void main() {
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: HomeScreen(),
    );
  }
}


3. ðŸ§¾ Provider Types
a) Provider (Read-only value)

final helloProvider = Provider<String>((ref) => "Hello Riverpod!");

Use in widget:

class HomeScreen extends ConsumerWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final message = ref.watch(helloProvider);
    return Scaffold(
      body: Center(child: Text(message)),
    );
  }
}

b) StateProvider (Simple state)
final counterProvider = StateProvider<int>((ref) => 0);

class CounterScreen extends ConsumerWidget {
  const CounterScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final count = ref.watch(counterProvider);

    return Scaffold(
      appBar: AppBar(title: const Text("Counter")),
      body: Center(
        child: Text("Count: $count", style: const TextStyle(fontSize: 24)),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => ref.read(counterProvider.notifier).state++,
        child: const Icon(Icons.add),
      ),
    );
  }
}

c) FutureProvider (Async data)

final userProvider = FutureProvider<String>((ref) async {
  await Future.delayed(const Duration(seconds: 2));
  return "Amit Kumar"; // Example API response
});

class UserScreen extends ConsumerWidget {
  const UserScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final asyncUser = ref.watch(userProvider);

    return Scaffold(
      body: Center(
        child: asyncUser.when(
          data: (user) => Text("User: $user"),
          loading: () => const CircularProgressIndicator(),
          error: (err, _) => Text("Error: $err"),
        ),
      ),
    );
  }
}

d) StreamProvider

final timeProvider = StreamProvider<String>((ref) async* {
  while (true) {
    await Future.delayed(const Duration(seconds: 1));
    yield DateTime.now().toIso8601String();
  }
});

class TimeScreen extends ConsumerWidget {
  const TimeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final time = ref.watch(timeProvider);

    return Scaffold(
      body: Center(
        child: time.when(
          data: (value) => Text(value),
          loading: () => const CircularProgressIndicator(),
          error: (e, _) => Text("Error: $e"),
        ),
      ),
    );
  }
}

e) StateNotifierProvider (For complex state)
import 'package:flutter_riverpod/flutter_riverpod.dart';

// State
class Todo {
  final String title;
  final bool isDone;
  Todo(this.title, {this.isDone = false});

  Todo copyWith({String? title, bool? isDone}) {
    return Todo(title ?? this.title, isDone: isDone ?? this.isDone);
  }
}

// Notifier
class TodoNotifier extends StateNotifier<List<Todo>> {
  TodoNotifier() : super([]);

  void add(String title) {
    state = [...state, Todo(title)];
  }

  void toggle(int index) {
    state = [
      for (int i = 0; i < state.length; i++)
        i == index ? state[i].copyWith(isDone: !state[i].isDone) : state[i]
    ];
  }
}

// Provider
final todoProvider = StateNotifierProvider<TodoNotifier, List<Todo>>((ref) {
  return TodoNotifier();
});

// UI
class TodoScreen extends ConsumerWidget {
  const TodoScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final todos = ref.watch(todoProvider);

    return Scaffold(
      appBar: AppBar(title: const Text("Todos")),
      body: ListView.builder(
        itemCount: todos.length,
        itemBuilder: (_, i) {
          final todo = todos[i];
          return ListTile(
            title: Text(todo.title,
                style: TextStyle(
                    decoration: todo.isDone
                        ? TextDecoration.lineThrough
                        : TextDecoration.none)),
            trailing: Checkbox(
              value: todo.isDone,
              onChanged: (_) => ref.read(todoProvider.notifier).toggle(i),
            ),
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () =>
            ref.read(todoProvider.notifier).add("Task ${todos.length + 1}"),
        child: const Icon(Icons.add),
      ),
    );
  }
}


4. ðŸ”„ Provider Lifecycles

1. ref.watch(provider) â†’ rebuilds when state changes

2. ref.read(provider) â†’ reads once, no rebuild

3. ref.listen(provider, (prev, next) { }) â†’ reacts to changes without rebuilding

Example:
ref.listen<int>(counterProvider, (prev, next) {
  if (next == 5) {
    ScaffoldMessenger.of(context)
        .showSnackBar(const SnackBar(content: Text("Reached 5!")));
  }
});


5. âœ… Best Practices

Use StateProvider for simple counters/toggles

Use StateNotifierProvider for business logic / multiple states

Use FutureProvider and StreamProvider for async APIs

Use Provider for constants or services (e.g., API client)

Keep logic in Notifiers not in Widgets





====================code=======================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// ------------------ PROVIDERS ------------------

// Simple read-only provider
final helloProvider = Provider<String>((ref) => "Hello Riverpod!");

// State provider (counter)
final counterProvider = StateProvider<int>((ref) => 0);

// Future provider (simulate API call)
final userProvider = FutureProvider<String>((ref) async {
  await Future.delayed(const Duration(seconds: 2));
  return "Amit Kumar (from API)";
});

// Stream provider (live clock)
final timeProvider = StreamProvider<String>((ref) async* {
  while (true) {
    await Future.delayed(const Duration(seconds: 1));
    yield DateTime.now().toIso8601String();
  }
});

// Todo state + notifier
class Todo {
  final String title;
  final bool isDone;
  Todo(this.title, {this.isDone = false});

  Todo copyWith({String? title, bool? isDone}) {
    return Todo(title ?? this.title, isDone: isDone ?? this.isDone);
  }
}

class TodoNotifier extends StateNotifier<List<Todo>> {
  TodoNotifier() : super([]);

  void add(String title) {
    state = [...state, Todo(title)];
  }

  void toggle(int index) {
    state = [
      for (int i = 0; i < state.length; i++)
        i == index ? state[i].copyWith(isDone: !state[i].isDone) : state[i]
    ];
  }
}

final todoProvider = StateNotifierProvider<TodoNotifier, List<Todo>>((ref) {
  return TodoNotifier();
});

/// ------------------ MAIN APP ------------------

void main() {
  runApp(const ProviderScope(child: MyApp()));
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: "Riverpod Demo",
      theme: ThemeData(primarySwatch: Colors.blue),
      home: const HomeTabs(),
    );
  }
}

/// ------------------ TAB NAVIGATION ------------------

class HomeTabs extends StatefulWidget {
  const HomeTabs({super.key});

  @override
  State<HomeTabs> createState() => _HomeTabsState();
}

class _HomeTabsState extends State<HomeTabs> {
  int _index = 0;

  final _screens = const [
    GreetingScreen(),
    CounterScreen(),
    UserScreen(),
    TimeScreen(),
    TodoScreen(),
  ];

  final _titles = [
    "Greeting",
    "Counter",
    "User (Future)",
    "Clock (Stream)",
    "Todos"
  ];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text(_titles[_index])),
      body: _screens[_index],
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _index,
        onTap: (i) => setState(() => _index = i),
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.message), label: "Hello"),
          BottomNavigationBarItem(icon: Icon(Icons.add), label: "Counter"),
          BottomNavigationBarItem(icon: Icon(Icons.person), label: "User"),
          BottomNavigationBarItem(icon: Icon(Icons.access_time), label: "Time"),
          BottomNavigationBarItem(icon: Icon(Icons.list), label: "Todos"),
        ],
      ),
    );
  }
}

/// ------------------ SCREENS ------------------

class GreetingScreen extends ConsumerWidget {
  const GreetingScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final message = ref.watch(helloProvider);
    return Center(child: Text(message, style: const TextStyle(fontSize: 24)));
  }
}

class CounterScreen extends ConsumerWidget {
  const CounterScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final count = ref.watch(counterProvider);
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text("Count: $count", style: const TextStyle(fontSize: 32)),
          const SizedBox(height: 20),
          ElevatedButton(
            onPressed: () => ref.read(counterProvider.notifier).state++,
            child: const Text("Increment"),
          ),
        ],
      ),
    );
  }
}

class UserScreen extends ConsumerWidget {
  const UserScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final asyncUser = ref.watch(userProvider);
    return Center(
      child: asyncUser.when(
        data: (user) => Text("User: $user", style: const TextStyle(fontSize: 24)),
        loading: () => const CircularProgressIndicator(),
        error: (err, _) => Text("Error: $err"),
      ),
    );
  }
}

class TimeScreen extends ConsumerWidget {
  const TimeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final time = ref.watch(timeProvider);
    return Center(
      child: time.when(
        data: (value) => Text(value, style: const TextStyle(fontSize: 20)),
        loading: () => const CircularProgressIndicator(),
        error: (e, _) => Text("Error: $e"),
      ),
    );
  }
}

class TodoScreen extends ConsumerWidget {
  const TodoScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final todos = ref.watch(todoProvider);

    return Column(
      children: [
        Expanded(
          child: ListView.builder(
            itemCount: todos.length,
            itemBuilder: (_, i) {
              final todo = todos[i];
              return ListTile(
                title: Text(
                  todo.title,
                  style: TextStyle(
                    decoration: todo.isDone
                        ? TextDecoration.lineThrough
                        : TextDecoration.none,
                  ),
                ),
                trailing: Checkbox(
                  value: todo.isDone,
                  onChanged: (_) => ref.read(todoProvider.notifier).toggle(i),
                ),
              );
            },
          ),
        ),
        Padding(
          padding: const EdgeInsets.all(12.0),
          child: ElevatedButton.icon(
            onPressed: () =>
                ref.read(todoProvider.notifier).add("Task ${todos.length + 1}"),
            icon: const Icon(Icons.add),
            label: const Text("Add Task"),
          ),
        ),
      ],
    );
  }
}
